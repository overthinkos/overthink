package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGenerateQuadlet(t *testing.T) {
	cfg := QuadletConfig{
		ImageName: "fedora-test",
		ImageRef:  "ghcr.io/atrawog/fedora-test:latest",
		Workspace: "/home/user/project",
		Ports:     []string{"8000:8000", "8080:8080"},
	}

	got := generateQuadlet(cfg)

	want := `# ov-fedora-test.container (generated by ov pod install)
[Unit]
Description=Overthink fedora-test
After=network-online.target

[Container]
Image=ghcr.io/atrawog/fedora-test:latest
ContainerName=ov-fedora-test
Volume=/home/user/project:/workspace
WorkingDir=/workspace
PublishPort=127.0.0.1:8000:8000
PublishPort=127.0.0.1:8080:8080
Exec=supervisord -n -c /etc/supervisord.conf

[Service]
Restart=always
TimeoutStartSec=900

[Install]
WantedBy=default.target
`

	if got != want {
		t.Errorf("generateQuadlet() =\n%s\nwant\n%s", got, want)
	}
}

func TestGenerateQuadletNoPorts(t *testing.T) {
	cfg := QuadletConfig{
		ImageName: "fedora",
		ImageRef:  "ghcr.io/atrawog/fedora:latest",
		Workspace: "/tmp/workspace",
		Ports:     nil,
	}

	got := generateQuadlet(cfg)

	if strings.Contains(got, "PublishPort") {
		t.Error("expected no PublishPort lines when ports are nil")
	}
	if !strings.Contains(got, "ContainerName=ov-fedora") {
		t.Error("expected ContainerName=ov-fedora")
	}
	if !strings.Contains(got, "Volume=/tmp/workspace:/workspace") {
		t.Error("expected Volume with workspace path")
	}
}

func TestGenerateQuadletSinglePort(t *testing.T) {
	cfg := QuadletConfig{
		ImageName: "myapp",
		ImageRef:  "myapp:latest",
		Workspace: "/home/user",
		Ports:     []string{"9090"},
	}

	got := generateQuadlet(cfg)

	if !strings.Contains(got, "PublishPort=127.0.0.1:9090:9090") {
		t.Errorf("expected single port to expand to 127.0.0.1:9090:9090, got:\n%s", got)
	}
	count := strings.Count(got, "PublishPort=")
	if count != 1 {
		t.Errorf("expected 1 PublishPort line, got %d", count)
	}
}

func TestServiceName(t *testing.T) {
	tests := []struct {
		image string
		want  string
	}{
		{"fedora", "ov-fedora.service"},
		{"fedora-test", "ov-fedora-test.service"},
		{"ubuntu", "ov-ubuntu.service"},
	}
	for _, tt := range tests {
		t.Run(tt.image, func(t *testing.T) {
			got := serviceName(tt.image)
			if got != tt.want {
				t.Errorf("serviceName(%q) = %q, want %q", tt.image, got, tt.want)
			}
		})
	}
}

func TestQuadletFilename(t *testing.T) {
	tests := []struct {
		image string
		want  string
	}{
		{"fedora", "ov-fedora.container"},
		{"fedora-test", "ov-fedora-test.container"},
	}
	for _, tt := range tests {
		t.Run(tt.image, func(t *testing.T) {
			got := quadletFilename(tt.image)
			if got != tt.want {
				t.Errorf("quadletFilename(%q) = %q, want %q", tt.image, got, tt.want)
			}
		})
	}
}

func TestQuadletDir(t *testing.T) {
	got, err := quadletDir()
	if err != nil {
		t.Fatalf("quadletDir() error: %v", err)
	}

	home, _ := os.UserHomeDir()
	want := filepath.Join(home, ".config", "containers", "systemd")
	if got != want {
		t.Errorf("quadletDir() = %q, want %q", got, want)
	}
}
