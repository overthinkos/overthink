package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// QuadletConfig holds the parameters for generating a quadlet .container file
type QuadletConfig struct {
	ImageName string        // image name from images.yml (e.g. "fedora-test")
	ImageRef  string        // full image reference (e.g. "ghcr.io/atrawog/fedora-test:latest")
	Workspace string        // absolute host path to mount at /workspace
	Ports     []string      // port mappings from images.yml (e.g. ["8000:8000", "8080:8080"])
	Volumes   []VolumeMount // named volumes from layer.yml declarations
	GPU       bool          // enable GPU passthrough via CDI (AddDevice=nvidia.com/gpu=all)
}

// generateQuadlet produces the contents of a quadlet .container file.
func generateQuadlet(cfg QuadletConfig) string {
	name := containerName(cfg.ImageName)
	var b strings.Builder

	b.WriteString(fmt.Sprintf("# %s.container (generated by ov enable)\n", name))
	b.WriteString("[Unit]\n")
	b.WriteString(fmt.Sprintf("Description=Overthink %s\n", cfg.ImageName))
	b.WriteString("After=network-online.target\n")

	b.WriteString("\n[Container]\n")
	b.WriteString(fmt.Sprintf("Image=%s\n", cfg.ImageRef))
	b.WriteString(fmt.Sprintf("ContainerName=%s\n", name))
	b.WriteString(fmt.Sprintf("Volume=%s:/workspace\n", cfg.Workspace))
	b.WriteString("WorkingDir=/workspace\n")
	for _, port := range cfg.Ports {
		b.WriteString(fmt.Sprintf("PublishPort=%s\n", localizePort(port)))
	}
	for _, vol := range cfg.Volumes {
		b.WriteString(fmt.Sprintf("Volume=%s:%s\n", vol.VolumeName, vol.ContainerPath))
	}
	if cfg.GPU {
		b.WriteString("AddDevice=nvidia.com/gpu=all\n")
	}
	b.WriteString("Exec=supervisord -n -c /etc/supervisord.conf\n")

	b.WriteString("\n[Service]\n")
	b.WriteString("Restart=always\n")
	b.WriteString("TimeoutStartSec=900\n")

	b.WriteString("\n[Install]\n")
	b.WriteString("WantedBy=default.target\n")

	return b.String()
}

// quadletDir returns the user-level quadlet directory.
func quadletDir() (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("determining home directory: %w", err)
	}
	return filepath.Join(home, ".config", "containers", "systemd"), nil
}

// quadletFilename returns the quadlet filename for an image.
func quadletFilename(imageName string) string {
	return containerName(imageName) + ".container"
}

// serviceName returns the systemd service name for an image.
func serviceName(imageName string) string {
	return containerName(imageName) + ".service"
}

// quadletExists checks whether a .container file exists for the given image.
func quadletExists(imageName string) (bool, error) {
	qdir, err := quadletDir()
	if err != nil {
		return false, err
	}
	qpath := filepath.Join(qdir, quadletFilename(imageName))
	_, err = os.Stat(qpath)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}
