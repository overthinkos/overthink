package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGenerateQuadlet(t *testing.T) {
	cfg := QuadletConfig{
		ImageName: "fedora-test",
		ImageRef:  "ghcr.io/atrawog/fedora-test:latest",
		Workspace: "/home/user/project",
		Ports:     []string{"8000:8000", "8080:8080"},
	}

	got := generateQuadlet(cfg)

	want := `# ov-fedora-test.container (generated by ov enable)
[Unit]
Description=Overthink fedora-test
After=network-online.target

[Container]
Image=ghcr.io/atrawog/fedora-test:latest
ContainerName=ov-fedora-test
Volume=/home/user/project:/workspace
WorkingDir=/workspace
PublishPort=127.0.0.1:8000:8000
PublishPort=127.0.0.1:8080:8080
Exec=supervisord -n -c /etc/supervisord.conf

[Service]
Restart=always
TimeoutStartSec=900

[Install]
WantedBy=default.target
`

	if got != want {
		t.Errorf("generateQuadlet() =\n%s\nwant\n%s", got, want)
	}
}

func TestGenerateQuadletNoPorts(t *testing.T) {
	cfg := QuadletConfig{
		ImageName: "fedora",
		ImageRef:  "ghcr.io/atrawog/fedora:latest",
		Workspace: "/tmp/workspace",
		Ports:     nil,
	}

	got := generateQuadlet(cfg)

	if strings.Contains(got, "PublishPort") {
		t.Error("expected no PublishPort lines when ports are nil")
	}
	if !strings.Contains(got, "ContainerName=ov-fedora") {
		t.Error("expected ContainerName=ov-fedora")
	}
	if !strings.Contains(got, "Volume=/tmp/workspace:/workspace") {
		t.Error("expected Volume with workspace path")
	}
}

func TestGenerateQuadletSinglePort(t *testing.T) {
	cfg := QuadletConfig{
		ImageName: "myapp",
		ImageRef:  "myapp:latest",
		Workspace: "/home/user",
		Ports:     []string{"9090"},
	}

	got := generateQuadlet(cfg)

	if !strings.Contains(got, "PublishPort=127.0.0.1:9090:9090") {
		t.Errorf("expected single port to expand to 127.0.0.1:9090:9090, got:\n%s", got)
	}
	count := strings.Count(got, "PublishPort=")
	if count != 1 {
		t.Errorf("expected 1 PublishPort line, got %d", count)
	}
}

func TestGenerateQuadletWithVolumes(t *testing.T) {
	cfg := QuadletConfig{
		ImageName: "openclaw",
		ImageRef:  "ghcr.io/atrawog/openclaw:latest",
		Workspace: "/home/user/project",
		Ports:     []string{"18789:18789"},
		Volumes: []VolumeMount{
			{VolumeName: "ov-openclaw-data", ContainerPath: "/home/user/.openclaw"},
		},
	}

	got := generateQuadlet(cfg)

	if !strings.Contains(got, "Volume=ov-openclaw-data:/home/user/.openclaw") {
		t.Errorf("expected Volume line for openclaw data, got:\n%s", got)
	}
	if !strings.Contains(got, "Volume=/home/user/project:/workspace") {
		t.Error("expected workspace Volume line")
	}
	if !strings.Contains(got, "PublishPort=127.0.0.1:18789:18789") {
		t.Error("expected PublishPort line")
	}
}

func TestGenerateQuadletWithGPU(t *testing.T) {
	cfg := QuadletConfig{
		ImageName: "ollama",
		ImageRef:  "ghcr.io/atrawog/ollama:latest",
		Workspace: "/home/user/project",
		GPU:       true,
	}

	got := generateQuadlet(cfg)

	if !strings.Contains(got, "AddDevice=nvidia.com/gpu=all") {
		t.Errorf("expected AddDevice=nvidia.com/gpu=all when GPU=true, got:\n%s", got)
	}
}

func TestGenerateQuadletWithoutGPU(t *testing.T) {
	cfg := QuadletConfig{
		ImageName: "fedora",
		ImageRef:  "ghcr.io/atrawog/fedora:latest",
		Workspace: "/home/user/project",
		GPU:       false,
	}

	got := generateQuadlet(cfg)

	if strings.Contains(got, "AddDevice") {
		t.Errorf("expected no AddDevice when GPU=false, got:\n%s", got)
	}
}

func TestServiceName(t *testing.T) {
	tests := []struct {
		image string
		want  string
	}{
		{"fedora", "ov-fedora.service"},
		{"fedora-test", "ov-fedora-test.service"},
		{"ubuntu", "ov-ubuntu.service"},
	}
	for _, tt := range tests {
		t.Run(tt.image, func(t *testing.T) {
			got := serviceName(tt.image)
			if got != tt.want {
				t.Errorf("serviceName(%q) = %q, want %q", tt.image, got, tt.want)
			}
		})
	}
}

func TestQuadletFilename(t *testing.T) {
	tests := []struct {
		image string
		want  string
	}{
		{"fedora", "ov-fedora.container"},
		{"fedora-test", "ov-fedora-test.container"},
	}
	for _, tt := range tests {
		t.Run(tt.image, func(t *testing.T) {
			got := quadletFilename(tt.image)
			if got != tt.want {
				t.Errorf("quadletFilename(%q) = %q, want %q", tt.image, got, tt.want)
			}
		})
	}
}

func TestQuadletDir(t *testing.T) {
	got, err := quadletDir()
	if err != nil {
		t.Fatalf("quadletDir() error: %v", err)
	}

	home, _ := os.UserHomeDir()
	want := filepath.Join(home, ".config", "containers", "systemd")
	if got != want {
		t.Errorf("quadletDir() = %q, want %q", got, want)
	}
}

func TestQuadletExists(t *testing.T) {
	tmpDir := t.TempDir()
	// Write a fake .container file
	systemdDir := filepath.Join(tmpDir, ".config", "containers", "systemd")
	os.MkdirAll(systemdDir, 0755)
	os.WriteFile(filepath.Join(systemdDir, "ov-testimg.container"), []byte("test"), 0644)

	// Override HOME so quadletDir resolves to our temp dir
	origHome := os.Getenv("HOME")
	os.Setenv("HOME", tmpDir)
	defer os.Setenv("HOME", origHome)

	exists, err := quadletExists("testimg")
	if err != nil {
		t.Fatalf("quadletExists() error: %v", err)
	}
	if !exists {
		t.Error("expected quadletExists to return true for existing file")
	}

	exists, err = quadletExists("nonexistent")
	if err != nil {
		t.Fatalf("quadletExists() error: %v", err)
	}
	if exists {
		t.Error("expected quadletExists to return false for nonexistent file")
	}
}
